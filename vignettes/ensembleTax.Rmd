---
title: "ensembleTax package Vignette"
author: "D Catlett"
date: "8/17/2020"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ensembleTax package Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# ensembleTax overview
ensembleTax is an R package that allows incorporation of information from 
multiple taxonomic assignment algorithms and/or reference databases to compute 
ensemble taxonomic assignments for ASVs/OTUs generated by common marker gene 
sequence analyses. 

Please note that this is a simple vignette to demonstrate the functionality of 
the package. For more detailed discussion and example uses, see here:
https://github.com/dcat4/ensembleTax/blob/master/README.md

## The problem
Taxonomic assignment of marker gene sequences is a critical step of marker gene
workflows as it imparts ecological significance and understanding to genetic 
data.

Many taxonomic assignment algorithms have been proposed to assign taxonomy to 
marker gene sequences (or OTUs/ASVs). Similarly, analysts are often forced to 
choose from one of several reference databases containing representative 
marker gene sequences with known taxonomic identities. The "best" assignment 
algorithm and/or reference database for a particular scientific question is 
often not obvious. To complicate things further, different reference databases 
generally do not share consistent taxonomic naming or ranking conventions. 

ensembleTax solves this problem by providing flexible algorithms that synthesize
information from multiple taxonomic assignment algorithm/reference database 
combinations and compute a single ensemble taxonomic assignment for each ASV/OTU
in a marker gene data set. 

## ensembleTax algorithms
The core algorithms employed by ensembleTax are *taxmapper* and *ensembleTax*.
*taxmapper* maps, or 'translates', one taxonomic nomenclature onto another by 
exact name matching. *taxmapper* is rank-agnostic, meaning it does not consider
the hierarchical structure of a taxonomy and assumes that a taxonomic name means
the same thing regardless of which reference database employs it. 

*ensembleTax* computes ensemble taxonomic assignments based on assignments 
determined by any number of individual taxonomic assignment algorithm/reference
database combinations. Several parameters allow the user to control trade-offs
in the accuracy vs. resolution of taxonomic assignments.

Additional functions are included for pre-processing taxonomic assignments 
generated by specific taxonomic assignment algorithms and reference databases. 
These functions are designed to conveniently plug in downstream of the dada2 
pipeline, but other pipelines may be used if the data is formatted properly for 
use with *taxmapper* and/or *ensembleTax*.

The taxonomic assignment algorithms explicitly supported by ensembleTax are:

1. bayesian classifier as implemented in dada2's assignTaxonomy.
2. idtaxa algorithm as implemented in DECIPHER. 

Supported reference databases include:

1. Silva SSU NR reference database (silva).
2. Protistan Ribosomal Reference database (pr2).
3. RDP train set v16
4. GreenGenes v13.8 clustered at 97% similarity

Note that other databases may still be used with ensembleTax, but they must be 
mapped onto the taxonomic nomenclatures employed by Silva and/or pr2 using 
*taxmapper*, or they must be re-formatted appropriately for use with 
*taxmapper*. Follow the link above for vignettes demonstrating how to 
incorporate custom reference databases into your ensembleTax workflow.

### ensembleTax 'pipeline' demonstration

Here we step through a simple example of an ensembleTax workflow to compute 
ensemble taxonomic assignments for a small set of 18S-V9 protist ASVs.

First, load some data included with the ensembleTax package. These are outputs
of dada2's assignTaxonomy implemented against pr2, and of DECIPHER's idtaxa 
implemented against both pr2 and silva. The rubric.sample is an example of a 
"rubric", which ensembleTax uses to track ASV-identifying information. 
The rubric is a DNAStringSet (see the Biostrings package) object produced by 
extracting ASV sequences from the seqtab used by dada2, and giving them 
arbitrary names (like sv1, sv2, etc). 

```{r}
library("ensembleTax")
library("Biostrings")

data("idtax.pr2.sample")
data("idtax.silva.sample")
data("bayes.sample")
data("rubric.sample")

head(idtax.pr2.sample)
head(idtax.silva.sample)
head(bayes.sample)
head(rubric.sample)
```

#### ensembleTax pre-processing

We see from the above that the data structures returned by our two taxonomic 
assignment algorithms are different. It is critically important that the order 
of sequences in the rubric and in the idtaxa-returned Taxon object are the same.
idtaxa does not return sequence names, but if you did not alter the order of 
your sequences as you provided them to idtaxa and/or DNAStringSet when creating 
your rubric, the ordering should be preserved and you should be good to go. 

Here we'll run these tables through ensembleTax's pre-processing functions. 
Supplying a rubric allows ensembleTax to give each taxonomy table the same ASV-
identifying information and to better track and organize your data.

```{r}
   
idtax.pr2.pretty <- idtax2df(idtax.pr2.sample, 
                             db = "pr2", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)
idtax.silva.pretty <- idtax2df(idtax.silva.sample, 
                             db = "silva", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)
bayes.pr2.pretty <- bayestax2df(bayes.sample, 
                             db = "pr2", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)

head(idtax.pr2.pretty)
head(idtax.silva.pretty)
head(bayes.pr2.pretty)

```

We see that each taxonomy table is now a dataframe sorted by the column "svN". 

#### The taxmapper algorithm

After pre-processing our taxonomic assignment data sets above, we see we still
can't make apples-to-apples comparisons across between the "idtax-silva" table 
and the two others because they employ different ranking and (though this may 
not be as obvious) naming conventions. *taxmapper* was created to solve this 
problem. 

Here we'll use taxmapper to 'translate' the idtax-silva taxonomic assignments 
onto the same taxonomic nomenclature as the other two tables.

```{r}

idtax.silva.mapped2pr2 <- taxmapper(idtax.silva.pretty,
                      tt.ranks = colnames(idtax.silva.pretty)[3:ncol(idtax.silva.pretty)],
                      tax2map2 = "pr2",
                      exceptions = c("Archaea", "Bacteria"),
                      ignore.format = TRUE,
                      synonym.file = "default",
                      streamline = TRUE,
                      outfilez = NULL)
head(idtax.silva.mapped2pr2)

```

Inspection of the mapped taxonomy table shows that it now mirrors the naming and
ranking conventions of the other two taxonomy tables.

#### The ensembleTax algorithm

Now we have three different taxonomy tables with independent taxonomic 
assignments for each ASV in our example data set. From these we can compute 
ensemble taxonomic assignments with the *ensembleTax* algorithm.

We'll do a few runs to show a range of outcomes that might be achieved by 
implementing the algorithm under different parameter spaces.

Here's a run with the default parameters:

```{r}

xx <- list(idtax.pr2.pretty, idtax.silva.mapped2pr2, bayes.pr2.pretty)
names(xx) <- c("idtax-pr2", "idtax-silva", "bayes-pr2")
eTax1 <- ensembleTax(xx, 
                     tablenames = names(xx), 
                     ranknames = c("kingdom", "supergroup", "division","class","order","family","genus","species"),
                     tiebreakz = "none", 
                     count.na=TRUE, 
                     assign.threshold = 0, 
                     weights=rep(1,length(xx)))
head(eTax1)

```

Just as an example of what is possible, we might tell *ensembleTax* not to count 
non-assignments (NA's) by setting *count.na = FALSE*. Further, we might specify 
that the assignments in the idtax-pr2 table should be weighted double the other 
two (*weights = c(2,1,1)*) if we suspect that these are the most robust 
assignments for our ASV data set. Here's what that looks like:

```{r}
eTax2 <- ensembleTax(xx, 
                     tablenames = names(xx), 
                     ranknames = c("kingdom", "supergroup", "division","class","order","family","genus","species"),
                     tiebreakz = "none", 
                     count.na=FALSE, 
                     assign.threshold = 0, 
                     weights=c(2,1,1))
head(eTax2)
```

One more making use of the tiebreakz argument: 

```{r}
eTax3 <- ensembleTax(xx, 
                     tablenames = names(xx), 
                     ranknames = c("kingdom", "supergroup", "division","class","order","family","genus","species"),
                     tiebreakz = c("bayes-pr2"), 
                     count.na=TRUE, 
                     assign.threshold = 0, 
                     weights=c(1,1,2))
head(eTax3)
```
